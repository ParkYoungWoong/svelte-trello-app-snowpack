"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveTargetsFromRemoteCDN = void 0;
const cacache_1 = __importDefault(require("cacache"));
const colors = __importStar(require("kleur/colors"));
const p_queue_1 = __importDefault(require("p-queue"));
const validate_npm_package_name_1 = __importDefault(require("validate-npm-package-name"));
const util_js_1 = require("./util.js");
const logger_1 = require("./logger");
/**
 * Given an install specifier, attempt to resolve it from the CDN.
 * If no lockfile exists or if the entry is not found in the lockfile, attempt to resolve
 * it from the CDN directly. Otherwise, use the URL found in the lockfile and attempt to
 * check the local cache first.
 *
 * All resolved URLs are populated into the local cache, where our internal Rollup engine
 * will load them from when it installs your dependencies to disk.
 */
async function resolveDependency(installSpecifier, packageSemver, lockfile, canRetry = true) {
    // Right now, the CDN is only for top-level JS packages. The CDN doesn't support CSS,
    // non-JS assets, and has limited support for deep package imports. Snowpack
    // will automatically fall-back any failed/not-found assets from local
    // node_modules/ instead.
    if (!validate_npm_package_name_1.default(installSpecifier).validForNewPackages) {
        return null;
    }
    // Grab the installUrl from our lockfile if it exists, otherwise resolve it yourself.
    let installUrl;
    let installUrlType;
    if (lockfile && lockfile.imports[installSpecifier]) {
        installUrl = lockfile.imports[installSpecifier];
        installUrlType = 'pin';
    }
    else {
        if (packageSemver === 'latest') {
            logger_1.logger.warn(`warn(${installSpecifier}): Not found in "dependencies". Using latest package version...`);
        }
        if (packageSemver.startsWith('npm:@reactesm') || packageSemver.startsWith('npm:@pika/react')) {
            logger_1.logger.error(`React workaround packages no longer needed! Revert to the official React & React-DOM packages.`);
            process.exit(1);
        }
        if (packageSemver.includes(' ') || packageSemver.includes(':')) {
            logger_1.logger.warn(`warn(${installSpecifier}): Can't fetch complex semver "${packageSemver}" from remote CDN.`);
            return null;
        }
        installUrlType = 'lookup';
        installUrl = `${util_js_1.PIKA_CDN}/${installSpecifier}@${packageSemver}`;
    }
    // Hashed CDN urls never change, so its safe to grab them directly from the local cache
    // without a network request.
    if (installUrlType === 'pin') {
        const cachedResult = await cacache_1.default.get.info(util_js_1.RESOURCE_CACHE, installUrl).catch(() => null);
        if (cachedResult) {
            if (cachedResult.metadata) {
                const { pinnedUrl } = cachedResult.metadata;
                return pinnedUrl;
            }
        }
    }
    // Otherwise, resolve from the CDN remotely.
    const { statusCode, headers, data } = await util_js_1.fetchCDNResource(installUrl);
    if (statusCode !== 200) {
        logger_1.logger.warn(`Failed to resolve [${statusCode}]: ${installUrl} (${data})`);
        logger_1.logger.warn(`Falling back to local copy...`);
        return null;
    }
    let importUrlPath = headers['x-import-url'];
    let pinnedUrlPath = headers['x-pinned-url'];
    const buildStatus = headers['x-import-status'];
    const typesUrlPath = headers['x-typescript-types'];
    const typesUrl = typesUrlPath && `${util_js_1.PIKA_CDN}${typesUrlPath}`;
    if (installUrlType === 'pin') {
        const pinnedUrl = installUrl;
        await cacache_1.default.put(util_js_1.RESOURCE_CACHE, pinnedUrl, data, {
            metadata: { pinnedUrl, typesUrl },
        });
        return pinnedUrl;
    }
    if (pinnedUrlPath) {
        const pinnedUrl = `${util_js_1.PIKA_CDN}${pinnedUrlPath}`;
        await cacache_1.default.put(util_js_1.RESOURCE_CACHE, pinnedUrl, data, {
            metadata: { pinnedUrl, typesUrl },
        });
        return pinnedUrl;
    }
    if (buildStatus === 'SUCCESS') {
        logger_1.logger.warn(`Failed to lookup [${statusCode}]: ${installUrl}`);
        logger_1.logger.warn(`Falling back to local copy...`);
        return null;
    }
    if (!canRetry || buildStatus === 'FAIL') {
        logger_1.logger.warn(`Failed to build: ${installSpecifier}@${packageSemver}`);
        logger_1.logger.warn(`Falling back to local copy...`);
        return null;
    }
    logger_1.logger.info(colors.cyan(`Building ${installSpecifier}@${packageSemver}... (This takes a moment, but will be cached for future use)`));
    if (!importUrlPath) {
        logger_1.logger.error('X-Import-URL header expected, but none received.');
        process.exit(1);
    }
    const { statusCode: lookupStatusCode } = await util_js_1.fetchCDNResource(importUrlPath);
    if (lookupStatusCode !== 200) {
        logger_1.logger.error(`Unexpected response [${lookupStatusCode}]: ${util_js_1.PIKA_CDN}${importUrlPath}`);
        process.exit(1);
    }
    return resolveDependency(installSpecifier, packageSemver, lockfile, false);
}
async function resolveTargetsFromRemoteCDN(lockfile, config) {
    const downloadQueue = new p_queue_1.default({ concurrency: 16 });
    const newLockfile = { imports: {} };
    let resolutionError;
    for (const [installSpecifier, installSemver] of Object.entries(config.webDependencies)) {
        downloadQueue.add(async () => {
            try {
                const resolvedUrl = await resolveDependency(installSpecifier, installSemver, lockfile);
                if (resolvedUrl) {
                    newLockfile.imports[installSpecifier] = resolvedUrl;
                }
            }
            catch (err) {
                resolutionError = resolutionError || err;
            }
        });
    }
    await downloadQueue.onIdle();
    if (resolutionError) {
        throw resolutionError;
    }
    return newLockfile;
}
exports.resolveTargetsFromRemoteCDN = resolveTargetsFromRemoteCDN;
//# sourceMappingURL=resolve-remote.js.map
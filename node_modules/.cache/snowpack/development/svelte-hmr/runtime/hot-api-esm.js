import { get_current_component, current_component, set_current_component } from '../../svelte/internal.js';

/**
 * Emulates forthcoming HMR hooks in Svelte.
 *
 * All references to private component state ($$) are now isolated in this
 * module.
 */

const captureState = cmp => {
  // sanity check: propper behaviour here is to crash noisily so that
  // user knows that they're looking at something broken
  if (!cmp) {
    throw new Error('Missing component')
  }
  if (!cmp.$$) {
    throw new Error('Invalid component')
  }
  const {
    $$: { callbacks, bound, ctx },
  } = cmp;
  const state = cmp.$capture_state();
  return { ctx, callbacks, bound, state }
};

// restoreState
//
// It is too late to restore context at this point because component instance
// function has already been called (and so context has already been read).
// Instead, we rely on setting current_component to the same value it has when
// the component was first rendered -- which fix support for context, and is
// also generally more respectful of normal operation.
//
const restoreState = (cmp, restore) => {
  if (!restore) {
    return
  }
  const { callbacks, bound } = restore;
  if (callbacks) {
    cmp.$$.callbacks = callbacks;
  }
  if (bound) {
    cmp.$$.bound = bound;
  }
  // props, props.$$slots are restored at component creation (works
  // better -- well, at all actually)
};

const get_current_component_safe = () => {
  // NOTE relying on dynamic bindings (current_component) makes us dependent on
  // bundler config (and apparently it does not work in demo-svelte-nollup)
  try {
    // unfortunately, unlike current_component, get_current_component() can
    // crash in the normal path (when there is really no parent)
    return get_current_component()
  } catch (err) {
    // ... so we need to consider that this error means that there is no parent
    //
    // that makes us tightly coupled to the error message but, at least, we
    // won't mute an unexpected error, which is quite a horrible thing to do
    if (err.message === 'Function called outside component initialization') {
      // who knows...
      return current_component
    } else {
      throw err
    }
  }
};

const createProxiedComponent = (
  Component,
  initialOptions,
  { onInstance, onMount, onDestroy }
) => {
  let cmp;
  let last;
  let options = initialOptions;

  const isCurrent = _cmp => cmp === _cmp;

  const assignOptions = (target, anchor, restore, noPreserveState) => {
    const props = Object.assign({}, options.props);
    if (!noPreserveState && restore.state) {
      props.$$inject = restore.state;
    }
    options = Object.assign({}, initialOptions, { target, anchor, props });
  };

  const instrument = targetCmp => {
    const createComponent = (Component, restore, previousCmp) => {
      set_current_component(parentComponent || previousCmp);
      const comp = new Component(options);
      restoreState(comp, restore);
      instrument(comp);
      return comp
    };

    // `conservative: true` means we want to be sure that the new component has
    // actually been successfuly created before destroying the old instance.
    // This could be useful for preventing runtime errors in component init to
    // bring down the whole HMR. Unfortunately the implementation bellow is
    // broken (FIXME), but that remains an interesting target for when HMR hooks
    // will actually land in Svelte itself.
    //
    // The goal would be to render an error inplace in case of error, to avoid
    // losing the navigation stack (especially annoying in native, that is not
    // based on URL navigation, so we lose the current page on each error).
    //
    targetCmp.$replace = (
      Component,
      {
        target = options.target,
        anchor = options.anchor,
        noPreserveState,
        conservative = false,
      }
    ) => {
      const restore = captureState(targetCmp);
      assignOptions(target, anchor, restore, noPreserveState);
      const previous = cmp;
      if (conservative) {
        try {
          const next = createComponent(Component, restore, previous);
          // prevents on_destroy from firing on non-final cmp instance
          cmp = null;
          previous.$destroy();
          cmp = next;
        } catch (err) {
          cmp = previous;
          throw err
        }
      } else {
        // prevents on_destroy from firing on non-final cmp instance
        cmp = null;
        if (previous) {
          // previous can be null if last constructor has crashed
          previous.$destroy();
        }
        cmp = createComponent(Component, restore, last);
        last = cmp;
      }
      return cmp
    };

    // NOTE onMount must provide target & anchor (for us to be able to determinate
    // 			actual DOM insertion point)
    //
    // 			And also, to support keyed list, it needs to be called each time the
    // 			component is moved (same as $$.fragment.m)
    if (onMount) {
      const m = targetCmp.$$.fragment.m;
      targetCmp.$$.fragment.m = (...args) => {
        const result = m(...args);
        onMount(...args);
        return result
      };
    }

    // NOTE onDestroy must be called even if the call doesn't pass through the
    //      component's $destroy method (that we can hook onto by ourselves, since
    //      it's public API) -- this happens a lot in svelte's internals, that
    //      manipulates cmp.$$.fragment directly, often binding to fragment.d,
    //      for example
    if (onDestroy) {
      targetCmp.$$.on_destroy.push(() => {
        if (isCurrent(targetCmp)) {
          onDestroy();
        }
      });
    }

    if (onInstance) {
      onInstance(targetCmp);
    }

    // Svelte 3 creates and mount components from their constructor if
    // options.target is present.
    //
    // This means that at this point, the component's `fragment.c` and,
    // most notably, `fragment.m` will already have been called _from inside
    // createComponent_. That is: before we have a chance to hook on it.
    //
    // Proxy's constructor
    //   -> createComponent
    //     -> component constructor
    //       -> component.$$.fragment.c(...) (or l, if hydrate:true)
    //       -> component.$$.fragment.m(...)
    //
    //   -> you are here <-
    //
    if (onMount) {
      const { target, anchor } = options;
      if (target) {
        onMount(target, anchor);
      }
    }
  };

  const parentComponent = get_current_component_safe();

  cmp = new Component(options);

  instrument(cmp);

  return cmp
};

/**
 * The HMR proxy is a component-like object whose task is to sit in the
 * component tree in place of the proxied component, and rerender each
 * successive versions of said component.
 */

const handledMethods = ['constructor', '$destroy'];
const forwardedMethods = ['$set', '$on'];

const logError = (msg, err) => {
  // eslint-disable-next-line no-console
  console.error('[HMR][Svelte]', msg);
  if (err) {
    // NOTE avoid too much wrapping around user errors
    // eslint-disable-next-line no-console
    console.error(err);
  }
};

const posixify = file => file.replace(/[/\\]/g, '/');

const getBaseName = id =>
  id
    .split('/')
    .pop()
    .split('.')
    .slice(0, -1)
    .join('.');

const capitalize = str => str[0].toUpperCase() + str.slice(1);

const getFriendlyName = id => capitalize(getBaseName(posixify(id)));

const getDebugName = id => `<${getFriendlyName(id)}>`;

const relayCalls = (getTarget, names, dest = {}) => {
  for (const key of names) {
    dest[key] = function(...args) {
      const target = getTarget();
      if (!target) {
        return
      }
      return target[key] && target[key].call(this, ...args)
    };
  }
  return dest
};

const isInternal = key => key !== '$$' && key.substr(0, 2) === '$$';

// This is intented as a somewhat generic / prospective fix to the situation
// that arised with the introduction of $$set in Svelte 3.24.1 -- trying to
// avoid giving full knowledge (like its name) of this implementation detail
// to the proxy. The $$set method can be present or not on the component, and
// its presence impacts the behaviour (but with HMR it will be tested if it is
// present _on the proxy_). So the idea here is to expose exactly the same $$
// props as the current version of the component and, for those that are
// functions, proxy the calls to the current component.
const relayInternalMethods = (proxy, cmp) => {
  // delete any previously added $$ prop
  Object.keys(proxy)
    .filter(isInternal)
    .forEach(key => {
      delete proxy[key];
    });
  // guard: no component
  if (!cmp) return
  // proxy current $$ props to the actual component
  Object.keys(cmp)
    .filter(isInternal)
    .forEach(key => {
      Object.defineProperty(proxy, key, {
        configurable: true,
        get() {
          const value = cmp[key];
          if (typeof value !== 'function') return value
          return (
            value &&
            function(...args) {
              return value.apply(this, args)
            }
          )
        },
      });
    });
};

const copyComponentProperties = (proxy, cmp, previous) => {
  //proxy custom methods
  const props = Object.getOwnPropertyNames(Object.getPrototypeOf(cmp));
  if (previous) {
    previous.forEach(prop => {
      delete proxy[prop];
    });
  }
  return props.filter(prop => {
    if (!handledMethods.includes(prop) && !forwardedMethods.includes(prop)) {
      Object.defineProperty(proxy, prop, {
        configurable: true,
        get() {
          return cmp[prop]
        },
        set(value) {
          // we're changing it on the real component first to see what it
          // gives... if it throws an error, we want to throw the same error in
          // order to most closely follow non-hmr behaviour.
          cmp[prop] = value;
          // who knows? maybe the value has been transformed somehow
          proxy[prop] = cmp[prop];
        },
      });
      return true
    }
  })
};

// everything in the constructor!
//
// so we don't polute the component class with new members
//
class ProxyComponent {
  constructor(
    {
      Adapter,
      id,
      debugName,
      current, // { Component, hotOptions: { noPreserveState, ... } }
      register,
    },
    options // { target, anchor, ... }
  ) {
    let cmp;
    let disposed = false;
    let lastError = null;

    const setComponent = _cmp => {
      cmp = _cmp;
      relayInternalMethods(this, cmp);
    };

    const getComponent = () => cmp;

    const destroyComponent = () => {
      // destroyComponent is tolerant (don't crash on no cmp) because it
      // is possible that reload/rerender is called after a previous
      // createComponent has failed (hence we have a proxy, but no cmp)
      if (cmp) {
        cmp.$destroy();
        setComponent(null);
      }
    };

    const refreshComponent = (target, anchor, conservativeDestroy) => {
      if (lastError) {
        lastError = null;
        adapter.rerender();
      } else {
        try {
          const noPreserveState = current.hotOptions.noPreserveState;
          const replaceOptions = { target, anchor, noPreserveState };
          if (conservativeDestroy) {
            replaceOptions.conservativeDestroy = true;
          }
          setComponent(cmp.$replace(current.Component, replaceOptions));
        } catch (err) {
          setError(err);
          if (
            !current.hotOptions.optimistic ||
            // non acceptable components (that is components that have to defer
            // to their parent for rerender -- e.g. accessors, named exports)
            // are most tricky, and they havent been considered when most of the
            // code has been written... as a result, they are especially tricky
            // to deal with, it's better to consider any error with them to be
            // fatal to avoid odities
            !current.canAccept ||
            (err && err.hmrFatal)
          ) {
            throw err
          } else {
            // const errString = String((err && err.stack) || err)
            logError(`Error during component init: ${debugName}`, err);
          }
        }
      }
    };

    const setError = err => {
      lastError = err;
      adapter.renderError(err);
    };

    const instance = {
      hotOptions: current.hotOptions,
      proxy: this,
      id,
      debugName,
      refreshComponent,
    };

    const adapter = new Adapter(instance);

    const { afterMount, rerender } = adapter;

    // $destroy is not called when a child component is disposed, so we
    // need to hook from fragment.
    const onDestroy = () => {
      // NOTE do NOT call $destroy on the cmp from here; the cmp is already
      //   dead, this would not work
      if (!disposed) {
        disposed = true;
        adapter.dispose();
        unregister();
      }
    };

    // ---- register proxy instance ----

    const unregister = register(rerender);

    // ---- augmented methods ----

    this.$destroy = () => {
      destroyComponent();
      onDestroy();
    };

    // ---- forwarded methods ----

    relayCalls(getComponent, forwardedMethods, this);

    // ---- create & mount target component instance ---

    try {
      let lastProperties;
      const _cmp = createProxiedComponent(current.Component, options, {
        onDestroy,
        onMount: afterMount,
        onInstance: comp => {
          // WARNING the proxy MUST use the same $$ object as its component
          // instance, because a lot of wiring happens during component
          // initialisation... lots of references to $$ and $$.fragment have
          // already been distributed around when the component constructor
          // returns, before we have a chance to wrap them (and so we can't
          // wrap them no more, because existing references would become
          // invalid)
          this.$$ = comp.$$;
          lastProperties = copyComponentProperties(this, comp, lastProperties);
        },
      });
      setComponent(_cmp);
    } catch (err) {
      setError(err);
      throw err
    }
  }
}

// TODO we should probably delete statics that were added on the previous
// iteration, to avoid the case where something removed in the code would
// remain available, and HMR would produce a different result than non-HMR --
// namely, we'd expect a crash if a static method is still used somewhere but
// removed from the code, and HMR would hide that until next reload
const copyStatics = (component, proxy) => {
  //forward static properties and methods
  for (const key in component) {
    proxy[key] = component[key];
  }
};

let fatalError = false;

const hasFatalError = () => fatalError;

/**
 * Creates a HMR proxy and its associated `reload` function that pushes a new
 * version to all existing instances of the component.
 */
function createProxy(Adapter, id, Component, hotOptions, canAccept) {
  const debugName = getDebugName(id);
  const instances = [];

  // current object will be updated, proxy instances will keep a ref
  const current = {
    Component,
    hotOptions,
    canAccept,
  };

  const name = `Proxy${debugName}`;

  // this trick gives the dynamic name Proxy<MyComponent> to the concrete
  // proxy class... unfortunately, this doesn't shows in dev tools, but
  // it stills allow to inspect cmp.constructor.name to confirm an instance
  // is a proxy
  const proxy = {
    [name]: class extends ProxyComponent {
      constructor(options) {
        try {
          super(
            {
              Adapter,
              id,
              debugName,
              current,
              register: rerender => {
                instances.push(rerender);
                const unregister = () => {
                  const i = instances.indexOf(rerender);
                  instances.splice(i, 1);
                };
                return unregister
              },
            },
            options
          );
        } catch (err) {
          // If we fail to create a proxy instance, any instance, that means
          // that we won't be able to fix this instance when it is updated.
          // Recovering to normal state will be impossible. HMR's dead.
          //
          // Fatal error will trigger a full reload on next update (reloading
          // right now is kinda pointless since buggy code still exists).
          //
          // NOTE Only report first error to avoid too much polution -- following
          // errors are probably caused by the first one, or they will show up
          // in turn when the first one is fixed ¯\_(ツ)_/¯
          //
          if (!fatalError) {
            fatalError = true;
            logError(
              `Unrecoverable error in ${debugName}: next update will trigger a ` +
                `full reload`
            );
          }
          throw err
        }
      }
    },
  }[name];

  // initialize static members
  copyStatics(current.Component, proxy);

  const update = newState => Object.assign(current, newState);

  // reload all existing instances of this component
  const reload = () => {
    // copy statics before doing anything because a static prop/method
    // could be used somewhere in the create/render call
    copyStatics(current.Component, proxy);

    const errors = [];

    instances.forEach(rerender => {
      try {
        rerender();
      } catch (err) {
        logError(`Failed to rerender ${debugName}`, err);
        errors.push(err);
      }
    });

    if (errors.length > 0) {
      return false
    }

    return true
  };

  const hasFatalError = () => fatalError;

  return { id, proxy, update, reload, hasFatalError, current }
}

/* eslint-env browser */

const logPrefix = '[HMR:Svelte]';

// eslint-disable-next-line no-console
const log = (...args) => console.log(logPrefix, ...args);

const domReload = () => {
  // eslint-disable-next-line no-undef
  const win = typeof window !== 'undefined' && window;
  if (win && win.location && win.location.reload) {
    log('Reload');
    win.location.reload();
  } else {
    log('Full reload required');
  }
};

const replaceCss = (previousId, newId) => {
  if (typeof document === 'undefined') return false
  if (!previousId) return false
  if (!newId) return false
  // svelte-xxx-style => svelte-xxx
  const previousClass = previousId.slice(0, -6);
  const newClass = newId.slice(0, -6);
  // eslint-disable-next-line no-undef
  document.querySelectorAll('.' + previousClass).forEach(el => {
    el.classList.remove(previousClass);
    el.classList.add(newClass);
  });
  return true
};

const removeStylesheet = cssId => {
  if (cssId == null) return
  if (typeof document === 'undefined') return
  // eslint-disable-next-line no-undef
  const el = document.getElementById(cssId);
  if (el) el.remove();
  return
};

const defaultArgs = {
  reload: domReload,
};

const makeApplyHmr = transformArgs => args => {
  const allArgs = transformArgs({ ...defaultArgs, ...args });
  return applyHmr(allArgs)
};

let needsReload = false;

function applyHmr(args) {
  const {
    id,
    cssId,
    nonCssHash,
    reload = domReload,
    // normalized hot API (must conform to rollup-plugin-hot)
    hot,
    hotOptions,
    Component,
    acceptable, // some types of components are impossible to HMR correctly
    ProxyAdapter,
  } = args;

  const existing = hot.data && hot.data.record;

  const canAccept = acceptable && (!existing || existing.current.canAccept);

  const r =
    existing || createProxy(ProxyAdapter, id, Component, hotOptions, canAccept);

  const cssOnly =
    hotOptions.injectCss &&
    existing &&
    nonCssHash &&
    existing.current.nonCssHash === nonCssHash;

  r.update({
    Component,
    hotOptions,
    canAccept,
    nonCssHash,
    cssId,
    previousCssId: r.current.cssId,
    cssOnly,
  });

  hot.dispose(data => {
    // handle previous fatal errors
    if (needsReload || hasFatalError()) {
      if (hotOptions && hotOptions.noReload) {
        log('Full reload required');
      } else {
        reload();
      }
    }

    // 2020-09-21 Snowpack master doesn't pass data as arg to dispose handler
    data = data || hot.data;

    data.record = r;

    if (r.current.cssId !== cssId) {
      if (hotOptions.cssEjectDelay) {
        setTimeout(() => removeStylesheet(cssId), hotOptions.cssEjectDelay);
      } else {
        removeStylesheet(cssId);
      }
    }
  });

  if (canAccept) {
    hot.accept(async arg => {
      const { bubbled } = arg || {};
      // NOTE Snowpack registers accept handlers only once, so we can NOT rely
      // on the surrounding scope variables -- they're not the last module!
      const { cssId: newCssId, previousCssId } = r.current;
      const cssChanged = newCssId !== previousCssId;
      // ensure old style sheet has been removed by now
      if (cssChanged) removeStylesheet(previousCssId);
      // guard: css only change
      if (
        // NOTE bubbled is provided only by rollup-plugin-hot, and we
        // can't safely assume a CSS only change without it... this means we
        // can't support CSS only injection with Nollup or Webpack currently
        bubbled === false && // WARNING check false, not falsy!
        r.current.cssOnly &&
        (!cssChanged || replaceCss(previousCssId, newCssId))
      ) {
        return
      }

      const success = await r.reload();

      if (hasFatalError() || (!success && !hotOptions.optimistic)) {
        needsReload = true;
      }
    });
  }

  // well, endgame... we won't be able to render next updates, even successful,
  // if we don't have proxies in svelte's tree
  //
  // since we won't return the proxy and the app will expect a svelte component,
  // it's gonna crash... so it's best to report the real cause
  //
  // full reload required
  //
  const proxyOk = r && r.proxy;
  if (!proxyOk) {
    throw new Error(`Failed to create HMR proxy for Svelte component ${id}`)
  }

  return r.proxy
}

const applyHmr$1 = makeApplyHmr(args =>
  Object.assign({}, args, {
    hot: args.m.hot,
  })
);

export { applyHmr$1 as applyHmr };
